# ERD (Entity Relationship Diagram) - Jira Lite Core Data Model

## Overview

This document describes the core database design for Jira Lite after V1 and V2 migrations, adopting a **multi-tenant isolation** architecture. Every table ensures tenant data isolation through the `org_id` field.

## Goals

- Multi-tenant isolation via `org_id` on tenant-owned tables
- Prevent cross-org references using composite FKs `(org_id, id)`
- Minimal RBAC via `org_memberships.role`: `ADMIN`, `MEMBER`

---

## Mermaid ERD Diagram

```mermaid
erDiagram
    ORG ||--o{ APP_USER : "manages(via org_membership)"
    ORG ||--o{ ORG_MEMBERSHIP : owns
    ORG ||--o{ PROJECT : owns
    ORG ||--o{ TICKET : owns
    ORG ||--o{ TICKET_COMMENT : owns
    ORG ||--o{ TICKET_ATTACHMENT : owns
    
    APP_USER ||--o{ ORG_MEMBERSHIP : "member of"
    APP_USER ||--o{ TICKET : "creates"
    APP_USER ||--o{ TICKET : "assigned to"
    APP_USER ||--o{ TICKET_COMMENT : "writes"
    APP_USER ||--o{ TICKET_ATTACHMENT : "uploads"
    
    PROJECT ||--o{ TICKET : contains
    TICKET ||--o{ TICKET_COMMENT : "has comments"
    TICKET ||--o{ TICKET_ATTACHMENT : "has attachments"
    
    ORG {
        uuid id PK
        text name
        timestamptz created_at
        timestamptz updated_at
    }
    
    APP_USER {
        uuid id PK
        text cognito_sub UK "V2"
        text email UK
        text display_name
        timestamptz created_at
        timestamptz updated_at
    }
    
    ORG_MEMBERSHIP {
        uuid org_id FK
        uuid user_id FK
        varchar role "ADMIN|MEMBER"
        varchar status "ACTIVE|INVITED|DISABLED" "V2"
        timestamptz created_at
        timestamptz updated_at "V2"
    }
    
    PROJECT {
        uuid id PK
        uuid org_id FK
        varchar key UK
        text name
        uuid created_by FK "V3"
        timestamptz created_at
        timestamptz updated_at
    }
    
    TICKET {
        uuid id PK
        uuid org_id FK
        uuid project_id FK
        varchar key UK
        text title
        text description
        varchar status "OPEN|IN_PROGRESS|DONE|CANCELLED"
        varchar priority "LOW|MEDIUM|HIGH|URGENT"
        uuid created_by FK
        uuid assignee_id FK
        timestamptz created_at
        timestamptz updated_at
    }
    
    TICKET_COMMENT {
        uuid id PK
        uuid org_id FK
        uuid ticket_id FK
        uuid author_id FK
        text body
        timestamptz created_at
        timestamptz updated_at "V2"
    }
    
    TICKET_ATTACHMENT {
        uuid id PK
        uuid org_id FK
        uuid ticket_id FK
        uuid uploaded_by FK
        text file_name
        text content_type
        bigint file_size
        text s3_key
        varchar upload_status "PENDING|UPLOADED|FAILED" "V2"
        timestamptz created_at
        timestamptz updated_at "V2"
    }
```

---

## Detailed Table Design

### 1. orgs (Organization Table)
**Purpose:** Represents an independent organization/tenant. All other tables associate with this organization through `org_id` to achieve multi-tenant isolation.

**Key Fields:**
- `id` (UUID PK): Unique organization identifier, generated by DB as random UUID
- `name` (TEXT NOT NULL): Organization name
- `created_at`/`updated_at`: Timestamps

**Characteristics:** No `org_id` field (itself is the tenant root)

---

### 2. users (User Table)
**Purpose:** Stores global user information. A user can belong to multiple organizations through org_membership association.

**Key Fields:**
- `id` (UUID PK): Unique user identifier
- `cognito_sub` (TEXT UNIQUE): AWS Cognito user identifier for authentication integration **(Added in V2)**
- `email` (TEXT UNIQUE): Email address (unique)
- `display_name` (TEXT): Display name
- `created_at`/`updated_at`: Timestamps

**Characteristics:**
- No `org_id` (global user table)
- Two UNIQUE constraints: cognito_sub (V2) and email
- Supports multiple organization memberships

---

### 3. org_memberships (Organization Membership Table)
**Purpose:** Defines the relationship between users and organizations, including roles. Implements minimal RBAC.

**Key Fields:**
- `org_id` (UUID FK): Organization ID
- `user_id` (UUID FK): User ID
- `role` (VARCHAR): `ADMIN` or `MEMBER` (enforced via CHECK constraint)
- `status` (VARCHAR): `ACTIVE`, `INVITED`, `DISABLED` (enforced via CHECK constraint) **(Added in V2)**
- `created_at` (TIMESTAMPTZ): Creation timestamp
- `updated_at` (TIMESTAMPTZ): Update timestamp **(Added in V2)**

**Characteristics:**
- PK: `(org_id, user_id)` composite key
- Implicit UNIQUE: one membership record per organization
- FK org_id → orgs.id ON DELETE CASCADE
- FK user_id → users.id ON DELETE CASCADE
- CHECK role: ADMIN | MEMBER
- CHECK status (V2): ACTIVE | INVITED | DISABLED
- Indexes: org_id, user_id

---

### 4. projects (Project Table)
**Purpose:** Represents a project within an organization. Tickets belong to Projects.

**Key Fields:**
- `id` (UUID PK)
- `org_id` (UUID FK NOT NULL): **Required for multi-tenant isolation**
- `project_key` (TEXT NOT NULL): Project key (e.g., "JIRA"), unique within organization
- `name` (TEXT NOT NULL): Project name
- `created_by` (UUID FK, nullable): Project creator user ID **(Added in V3)**
- `created_at`/`updated_at`: Timestamps

**Characteristics:**
- UNIQUE `(org_id, project_key)`: Project key is unique within organization
- UNIQUE `(org_id, id)`: Composite unique constraint for cross-org reference prevention
- FK org_id → orgs.id ON DELETE CASCADE
- FK created_by → users.id ON DELETE SET NULL (V3: preserve project even if creator is deleted)
- Indexes: org_id, created_by (V3), (org_id, created_by) composite (V3), (org_id, updated_at DESC) (V3)

---

### 5. tickets (Ticket Table)
**Purpose:** Represents a ticket/task. Supports status and priority management.

**Key Fields:**
- `id` (UUID PK)
- `org_id` (UUID FK NOT NULL): **Required for multi-tenant isolation**
- `project_id` (UUID FK NOT NULL): Associated project
- `ticket_key` (VARCHAR NOT NULL): Ticket key (e.g., "JIRA-123"), unique within organization
- `title` (TEXT NOT NULL): Ticket title
- `description` (TEXT): Ticket description
- `status` (TEXT NOT NULL DEFAULT 'OPEN'): `OPEN`, `IN_PROGRESS`, `DONE`, `CANCELLED`
- `priority` (TEXT NOT NULL DEFAULT 'MEDIUM'): `LOW`, `MEDIUM`, `HIGH`, `URGENT`
- `created_by` (UUID FK): Creator user ID (null allowed)
- `assignee_id` (UUID FK, nullable): Assigned user
- `created_at`/`updated_at`: Timestamps

**Characteristics:**
- UNIQUE `(org_id, ticket_key)`: Ticket key is unique within organization
- UNIQUE `(org_id, id)`: Composite unique constraint for cross-org reference prevention
- CHECK status: OPEN | IN_PROGRESS | DONE | CANCELLED
- CHECK priority: LOW | MEDIUM | HIGH | URGENT
- FK org_id → orgs.id ON DELETE CASCADE
- FK (org_id, project_id) → projects(org_id, id) ON DELETE RESTRICT (prevents cross-tenant references)
- FK created_by → users.id ON DELETE SET NULL
- FK assignee_id → users.id ON DELETE SET NULL
- Indexes (V1): org_id, project_id, status, created_at
- Indexes (V2): (org_id, project_id, status) composite, updated_at DESC

---

### 6. ticket_comments (Ticket Comment Table)
**Purpose:** Stores comments on tickets. Supports discussion and collaboration.

**Key Fields:**
- `id` (UUID PK)
- `org_id` (UUID FK NOT NULL): **Required for multi-tenant isolation**
- `ticket_id` (UUID FK NOT NULL): Associated ticket
- `author_id` (UUID FK, nullable): Comment author user ID
- `body` (TEXT NOT NULL): Comment content
- `created_at` (TIMESTAMPTZ NOT NULL): Creation timestamp
- `updated_at` (TIMESTAMPTZ NOT NULL): Update timestamp **(Added in V2)**

**Characteristics:**
- FK org_id → orgs.id ON DELETE CASCADE
- FK (org_id, ticket_id) → tickets(org_id, id) ON DELETE CASCADE
- FK author_id → users.id ON DELETE SET NULL
- Indexes (V1): org_id, ticket_id
- Indexes (V2): (ticket_id, created_at) composite

---

### 7. ticket_attachments (Ticket Attachment Table)
**Purpose:** Stores ticket attachment metadata. Supports file uploads and S3 integration.

**Key Fields:**
- `id` (UUID PK)
- `org_id` (UUID FK NOT NULL): **Required for multi-tenant isolation**
- `ticket_id` (UUID FK NOT NULL): Associated ticket
- `uploaded_by` (UUID FK, nullable): Uploader user ID
- `file_name` (TEXT NOT NULL): File name
- `content_type` (TEXT NOT NULL): MIME type
- `file_size` (BIGINT NOT NULL DEFAULT 0): File size in bytes
- `s3_key` (TEXT): S3 storage object key
- `upload_status` (VARCHAR NOT NULL DEFAULT 'UPLOADED'): `PENDING`, `UPLOADED`, `FAILED` **(Added in V2)**
- `created_at` (TIMESTAMPTZ NOT NULL): Creation timestamp
- `updated_at` (TIMESTAMPTZ NOT NULL): Update timestamp **(Added in V2)**

**Characteristics:**
- FK org_id → orgs.id ON DELETE CASCADE
- FK (org_id, ticket_id) → tickets(org_id, id) ON DELETE CASCADE
- FK uploaded_by → users.id ON DELETE SET NULL
- CHECK upload_status (V2): PENDING | UPLOADED | FAILED
- Indexes (V1): org_id, ticket_id
- Indexes (V2): (ticket_id, created_at) composite

---

## Multi-Tenant Isolation Strategy

### Why Does Every Table Have org_id?

1. **Data Security**: Prevents cross-tenant data leakage. Even if SQL queries omit WHERE org_id conditions, application layer can compensate.
2. **Query Performance**: org_id as first index column accelerates tenant data retrieval.
3. **Simplified FK Design**: Composite keys `(org_id, id)` prevent erroneous cross-tenant references.
4. **Industry Best Practice**: Standard approach in multi-tenant systems.

### Exceptions
- `orgs` table: Itself is the tenant root, doesn't need org_id
- `users` table: Global user table, can belong to multiple organizations, doesn't need org_id

---

## Common Query Patterns

### 1. Get All Projects in Organization
```sql
SELECT * FROM projects 
WHERE org_id = $1 
ORDER BY created_at DESC;
```
**Index Support**: org_id

### 2. Get Tickets in Project with Filtering and Sorting
```sql
SELECT * FROM tickets 
WHERE org_id = $1 AND project_id = $2 AND status = $3 
ORDER BY updated_at DESC;
```
**Index Support**: `(org_id, project_id, status)` composite index (V2)

### 3. Get Ticket Detail with Comments
```sql
SELECT t.*, c.* FROM tickets t 
LEFT JOIN ticket_comments c ON t.org_id = c.org_id AND t.id = c.ticket_id 
WHERE t.org_id = $1 AND t.id = $2 
ORDER BY c.created_at ASC;
```
**Index Support**: ticket_id, (ticket_id, created_at) (V2)

### 4. Get Ticket Attachments
```sql
SELECT * FROM ticket_attachments 
WHERE org_id = $1 AND ticket_id = $2 
ORDER BY created_at DESC;
```
**Index Support**: (ticket_id, created_at) (V2)

### 5. Get User's Organizations
```sql
SELECT o.* FROM orgs o 
JOIN org_memberships om ON o.id = om.org_id 
WHERE om.user_id = $1 AND om.status = 'ACTIVE';
```
**Index Support**: org_memberships(user_id)

### 6. Get Organization Members
```sql
SELECT u.*, om.role FROM users u 
JOIN org_memberships om ON u.id = om.user_id 
WHERE om.org_id = $1 AND om.status = 'ACTIVE';
```
**Index Support**: org_memberships(org_id)

---

## Index Design Summary

### Indexes by Version

**V1 Indexes:**
- org_memberships(org_id, user_id)
- projects(org_id)
- tickets(org_id, project_id, status, created_at)
- ticket_comments(org_id, ticket_id)
- ticket_attachments(org_id, ticket_id)

**V2 Enhancements:**
- tickets(org_id, project_id, status) - optimized composite for filtering
- tickets(updated_at DESC) - for recent ticket sorting
- ticket_comments(ticket_id, created_at) - for pagination with time ordering
- ticket_attachments(ticket_id, created_at) - for pagination with time ordering

**V3 Completions:**
- projects(created_by) - query projects created by user
- projects(org_id, created_by) - composite for user's projects in organization
- projects(org_id, updated_at DESC) - recent projects in organization

### Why These Indexes?

| Table | Index | Query Pattern | Benefit |
|---|---|---|---|
| org_memberships | org_id | Query organization members | Fast member list scan |
| org_memberships | user_id | Query user's organizations | Fast tenant lookup |
| projects | org_id | List organization projects | Tenant isolation + fast scan |
| tickets | org_id | Basic multi-tenant filter | Tenant isolation |
| tickets | project_id | Query project tickets | Fast ticket location in project |
| tickets | (org_id, project_id, status) | Complex conditional queries | Support WHERE predicate push-down (V2) |
| tickets | updated_at DESC | Sort recent tickets | Support ORDER BY optimization (V2) |
| ticket_comments | (ticket_id, created_at) | Get ticket comments (time ordered) | Efficient range query + sort (V2) |
| ticket_comments | org_id | Tenant-level filter | Ensure isolation |
| ticket_attachments | (ticket_id, created_at) | Get attachment list (time ordered) | Support pagination + sort (V2) |
| ticket_attachments | org_id | Tenant-level filter | Ensure isolation |

---

## Migration Timeline

### V1 - Initial Schema
Creates core 7-table structure with multi-tenant isolation, composite FKs, and basic indexes.

### V2 - Core Domain Enhancements
Extends tables with audit trail fields and new enum fields:
- Adds `status` to org_memberships (membership lifecycle management)
- Adds `cognito_sub` to users (authentication integration)
- Adds `upload_status` to ticket_attachments (upload workflow tracking)
- Adds `updated_at` to org_memberships, ticket_comments, ticket_attachments
- Optimizes indexes for common query patterns

### V3 - Schema Completion
Completes the design by adding missing fields and optimized query paths:
- Adds `created_by` to projects (project creator tracking)
- Adds FK projects.created_by → users.id ON DELETE SET NULL
- Adds composite indexes for efficient user project queries
- Adds recent projects index (org_id, updated_at DESC)
- Validates all constraints from V1+V2

---

## Summary

This ERD design (V1 + V2):
- ✅ Fully supports multi-tenant isolation (org_id on every tenant-owned table)
- ✅ Uses composite FK `(org_id, id)` to prevent cross-tenant references
- ✅ Provides minimal RBAC (role: ADMIN/MEMBER, status: ACTIVE/INVITED/DISABLED)
- ✅ Includes all core business entities (organization, user, project, ticket, comment, attachment)
- ✅ Optimized indexes supporting common query patterns
- ✅ Uses CHECK constraints for enum-like fields (avoids Postgres ENUM)
- ✅ Includes audit trail timestamps (created_at, updated_at)
- ✅ Supports authentication integration (cognito_sub in V2)
- ✅ Supports file upload workflows (upload_status in V2)


